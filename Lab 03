#include <vector>
#include <iostream>
#include <string>
#include <fstream>
#include <memory>
#include <cstdlib>
using namespace std;


template<typename T>
class BagInterface
{
public:

	virtual int getCurrentSize() const = 0;

	virtual bool isEmpty() const = 0;

	virtual void clear() = 0;

	virtual int getFrequencyOf(const T& anEntry) const = 0;

	virtual bool contains(const T& anEntry) const = 0;
}; // end BagInterface


/*********************************************************************
Class Node
**********************************************************************/


template <typename T>
class Node
{

private:
	int itemCount;
	T	item; // A data item
	Node<T>* next; // Pointer to next node

public:

	Node() :itemCount(0), next(nullptr)
	{
	} // end default constructor

	Node(const T& anItem) : item(anItem), next(nullptr)
	{
	} // end constructor

	Node(const T& anItem, Node<T>* nextNodePtr) :
		item(anItem), next(nextNodePtr)
	{
	} // end constructor

	void setItem(const T& anItem)
	{
		item = anItem;
	} // end setItem

	void setNext(Node<T>* a)
	{
		next = a;
	}

	T getItem() const
	{
		return item;
	} // end getItem

	Node<T>* getNext() const
	{
		return next;
	} // end getNext

	int getitemCount()
	{
		reutrn itemCount;
	}
	void addCount()
	{
		itemCount++;
	}
}; // end Node



/*********************************************************************
Class LinkedBag
**********************************************************************/

template <typename T>
class LinkedBag : public BagInterface<T>
{
private:

	Node<T>* headPtr; // Pointer to first node
	Node<T>* rearPtr;
	int itemCount;

public:
	LinkedBag() : headPtr(new Node<T>), itemCount(0), rearPtr(headPtr)
	{
		
	}  // end default constructor

	LinkedBag(const LinkedBag<T>& aBag)
	{
		itemCount = aBag.itemCount;
		Node<T>* origChainPtr = aBag.headPtr;  // Points to nodes in original chain

		if (origChainPtr == nullptr)
			headPtr = nullptr;  // Original bag is empty

		else
		{
			// Copy first node
			headPtr = new Node<T>();
			headPtr->setItem(origChainPtr->getItem());

			// Copy remaining nodes
			Node<T>* newChainPtr = headPtr;      // Points to last node in new chain
			origChainPtr = origChainPtr->getNext();     // Advance original-chain pointer

			while (origChainPtr != nullptr)
			{
				// Get next item from original chain
				T nextItem = origChainPtr->getItem();

				// Create a new node containing the next item
				Node<T>* newNodePtr = new Node<T>(nextItem);

				// Link new node to end of new chain
				newChainPtr->setNext(newNodePtr);

				// Advance pointer to new last node
				newChainPtr = newChainPtr->getNext();

				// Advance original-chain pointer
				origChainPtr = origChainPtr->getNext();
			}  // end while

			newChainPtr->setNext(nullptr);              // Flag end of chain
		}  // end if
	}  // end copy constructor

	~LinkedBag()
	{
		clear();
	}  // end destructor

	bool isEmpty() const
	{
		return itemCount == 0;
	}  // end isEmpty

	int getCurrentSize() const
	{
		return itemCount;
	}  // end getCurrentSize

	void clear()
	{
		Node<T>* nodeToDeletePtr = headPtr;
		while (headPtr != nullptr)
		{
			headPtr = headPtr->getNext();

			// Return node to the system
			nodeToDeletePtr->setNext(nullptr);
			delete nodeToDeletePtr;

			nodeToDeletePtr = headPtr;
		}  // end while

		itemCount = 0;
	}  // end clear

	int getFrequencyOf(const T& anEntry) const
	{
		int frequency = 0;
		int counter = 0;
		Node<T>* curPtr = headPtr;
		while ((curPtr != nullptr) && (counter < itemCount))
		{
			if (anEntry == curPtr->getItem())
			{
				frequency++;
			} // end if

			counter++;
			curPtr = curPtr->getNext();
		} // end while

		return frequency;
	}  // end getFrequencyOf

	bool contains(const T& anEntry) const
	{
		return (getPointerTo(anEntry) != nullptr);
	}  // end contains

	Node<T>* getPointerTo(const T& anEntry) const
	{
		bool found = false;
		Node<T>* curPtr = headPtr;

		while (!found && (curPtr != nullptr))
		{
			if (anEntry == curPtr->getItem())
				found = true;
			else
				curPtr = curPtr->getNext();
		} // end while

		return curPtr;
	} // end getPointerTo

	Node<T>* getHead()
	{
		return headPtr;
	}

	Node<T>* getRear()
	{
		return rearPtr;
	}

	void output(LinkedBag<T>& bag)
	{

		
		Node<T>* rover = new Node<T>();
		rover = bag.getHead();

		for (int i = 0; i < itemCount; i++)
		{
			cout << rover->getItem();
			rover = rover->getNext();
		}


	}

	friend ostream& operator << (ostream& stream, LinkedBag<T>& bag)
	{
		cout << "The bag contains " << bag.getCurrentSize() << " items:" << endl;
		Node<T>* rover = bag.getHead();
		while (rover != nullptr)
		{
			cout << rover->getItem();
			rover = rover->getNext();
		}  // end for
		cout << endl << endl;
		return stream;
	}  // end displayBag

	bool enqeue(const T& text);
	bool adder(Node<T>* ptr, T ch);


}; // end LinkedBag



/*********************************************************************
Enqueue
**********************************************************************/

template<typename T>
bool LinkedBag<T>::enqeue(const T& letter)
{

	return adder(headPtr, letter);
}




/*********************************************************************
Adder
**********************************************************************/
template<typename T>
bool LinkedBag<T>::adder(Node<T>* ptr, T ch)
{
	if (itemCount > 0)
	{
		if (ch == ptr->getItem())
		{
			ptr->addCount();
			return true;
		}
		else
		{
			return adder(ptr->getNext(), ch);
		}
	}

	else
	{
		
		Node<T>* nuNode = new Node<T>(ch);

		if (itemCount = 0)
		{
			headPtr =  nuNode;
		}
		
		rearPtr->setNext(nuNode);
		rearPtr = nuNode;
		nuNode->addCount();
		itemCount++;
		
		return true;
	}
}

/*********************************************************************
sort
**********************************************************************/




/*********************************************************************
sort recursion
**********************************************************************/




/*********************************************************************
Main
**********************************************************************/

int main()
{
	char b;
	string a;
	ifstream infile;
	infile.open("Speech.txt");
	LinkedBag<char> bag;

	if (infile.is_open())
	{
		while (!infile.eof())
		{
			getline(infile, a);
			for (int i = 0; i < a.length(); i++)
			{
				b = a[i];
				bag.enqeue(b);
			}
		}
	}
	else

	{
		cout << "No file found\n";
	}

	bag.output(bag);


	getchar();


}  // end main

//MAKE SURE TO REMEBER TO PUT BACK THE DEBUG FUNCTION 
