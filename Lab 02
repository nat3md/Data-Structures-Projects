#include <vector>
#include <iostream>
#include <string>
using namespace std;

template<typename T>
class BagInterface
{
public:
	/** Gets the current number of entries in this bag.
	@return The integer number of entries currently in the bag. */
	virtual int getCurrentSize() const = 0;

	/** Sees whether this bag is empty.
	@return True if the bag is empty, or false if not. */
	virtual bool isEmpty() const = 0;

	/** Adds a new entry to this bag.
	@post  If successful, newEntry is stored in the bag and
	the count of items in the bag has increased by 1.
	@param newEntry  The object to be added as a new entry.
	@return  True if addition was successful, or false if not. */


	

	/** Removes one occurrence of a given entry from this bag,
	if possible.
	@post  If successful, anEntry has been removed from the bag
	and the count of items in the bag has decreased by 1.
	@param anEntry  The entry to be removed.
	@return  True if removal was successful, or false if not. */

	/** Removes all entries from this bag.
	@post  Bag contains no items, and the count of items is 0. */
	virtual void clear() = 0;

	/** Counts the number of times a given entry appears in bag.
	@param anEntry  The entry to be counted.
	@return  The number of times anEntry appears in the bag. */
	virtual int getFrequencyOf(const T& anEntry) const = 0;

	/** Tests whether this bag contains a given entry.
	@param anEntry  The entry to locate.
	@return  True if bag contains anEntry, or false otherwise. */
	virtual bool contains(const T& anEntry) const = 0;
}; // end BagInterface

template <typename T>
class Node
{
private:
	T	item; // A data item
	Node<T>* next; // Pointer to next node
public:
	Node() : next(nullptr)
	{
	} // end default constructor
	Node(const T& anItem) : item(anItem), next(nullptr)
	{
	} // end constructor
	Node(const T& anItem, Node<T>* nextNodePtr) :
		item(anItem), next(nextNodePtr)
	{
	} // end constructor
	void setItem(const T& anItem)
	{
		item = anItem;
	} // end setItem
	void Node<T>::setNext(Node<T>* nextNodePtr)
	{
		next = nextNodePtr;
	} // end setNext
	T getItem() const
	{
		return item;
	} // end getItem
	Node<T>* getNext() const
	{
		return next;
	} // end getNext
}; // end Node

template <typename T>
class LinkedBag : public BagInterface<T>
{
private:
	Node<T>* headPtr; // Pointer to first node
	int itemCount;

	// Current count of bag items
	// Returns either a pointer to the node containing a given entry
	// or the null pointer if the entry is not in the bag.
public:
	LinkedBag() : headPtr(nullptr), itemCount(0)
	{
	}  // end default constructor
	LinkedBag(const LinkedBag<T>& aBag)
	{
		itemCount = aBag.itemCount;
		Node<T>* origChainPtr = aBag.headPtr;  // Points to nodes in original chain

		if (origChainPtr == nullptr)
			headPtr = nullptr;  // Original bag is empty
		else
		{
			// Copy first node
			headPtr = new Node<T>();
			headPtr->setItem(origChainPtr->getItem());

			// Copy remaining nodes
			Node<T>* newChainPtr = headPtr;      // Points to last node in new chain
			origChainPtr = origChainPtr->getNext();     // Advance original-chain pointer

			while (origChainPtr != nullptr)
			{
				// Get next item from original chain
				T nextItem = origChainPtr->getItem();

				// Create a new node containing the next item
				Node<T>* newNodePtr = new Node<T>(nextItem);

				// Link new node to end of new chain
				newChainPtr->setNext(newNodePtr);

				// Advance pointer to new last node
				newChainPtr = newChainPtr->getNext();

				// Advance original-chain pointer
				origChainPtr = origChainPtr->getNext();
			}  // end while

			newChainPtr->setNext(nullptr);              // Flag end of chain
		}  // end if
	}  // end copy constructor
	~LinkedBag()
	{
		clear();
	}  // end destructor
	bool isEmpty() const
	{
		return itemCount == 0;
	}  // end isEmpty
	int getCurrentSize() const
	{
		return itemCount;
	}  // end getCurrentSize
	bool push(const T& newItem)
	{
		Node<T>* newNodePtr = new Node<T>(newItem, headPtr);
		headPtr = newNodePtr;
		newNodePtr = nullptr;

		return true;
	}  // end push

	bool pop()
	{
		bool result = false;
		if (!isEmpty())
		{
			// Stack is not empty; delete top
			Node<T>* nodeToDeletePtr = headPtr;
			headPtr = headPtr->getNext();

			// Return deleted node to system
			nodeToDeletePtr->setNext(nullptr);
			delete nodeToDeletePtr;
			nodeToDeletePtr = nullptr;

			result = true;
		}  // end if

		return result;
	}  // end pop



	

	void clear()
	{
		Node<T>* nodeToDeletePtr = headPtr;
		while (headPtr != nullptr)
		{
			headPtr = headPtr->getNext();

			// Return node to the system
			nodeToDeletePtr->setNext(nullptr);
			delete nodeToDeletePtr;

			nodeToDeletePtr = headPtr;
		}  // end while
		   // headPtr is nullptr; nodeToDeletePtr is nullptr

		itemCount = 0;
	}  // end clear
	int getFrequencyOf(const T& anEntry) const
	{
		int frequency = 0;
		int counter = 0;
		Node<T>* curPtr = headPtr;
		while ((curPtr != nullptr) && (counter < itemCount))
		{
			if (anEntry == curPtr->getItem())
			{
				frequency++;
			} // end if

			counter++;
			curPtr = curPtr->getNext();
		} // end while

		return frequency;
	}  // end getFrequencyOf
	bool contains(const T& anEntry) const
	{
		return (getPointerTo(anEntry) != nullptr);
	}  // end contains
	Node<T>* getPointerTo(const T& anEntry) const
	{
		bool found = false;
		Node<T>* curPtr = headPtr;

		while (!found && (curPtr != nullptr))
		{
			if (anEntry == curPtr->getItem())
				found = true;
			else
				curPtr = curPtr->getNext();
		} // end while

		return curPtr;
	} // end getPointerTo
	Node<T>* getHead()
	{
		return headPtr;
	}

	void output(LinkedBag<T>& bag)
	{


		Node<T>* rover = new Node<T>();
		rover = bag.getHead();

		for (int i = 0; i < itemCount; i++)
		{
			cout << rover->getItem();
			rover = rover->getNext();
		}


	}
	friend ostream& operator << (ostream& stream, LinkedBag<T>& bag)
	{
		cout << "The bag contains " << bag.getCurrentSize() << " items:" << endl;
		Node<T>* rover = bag.getHead();
		while (rover != nullptr)
		{
			cout << rover->getItem();
			rover = rover->getNext();
		}  // end for
		cout << endl << endl;
		return stream;
	}  // end displayBag
}; // end LinkedBag

int IsRightAssociative(char a)
{
	if (a = '$') return true;
	return false;
}

bool IsOperand(char C)
{
	if (C >= '0' && C <= '9') return true;
	if (C >= 'a' && C <= 'z') return true;
	if (C >= 'A' && C <= 'Z') return true;

}

bool IsOperantor(char C)
{
	if (C == '+' || C == '-' || C == '/' || C == '$')
	{
		return true;
	}

	else
		return false;
}

int operatorWeight(char a)
{
	int weight =-1;

	switch (a)
	{
	case '+':
	case'-':
		weight = 1;
	case '*':
	case'/':
		weight = 2;
	case '$':
		weight = 3;
	}
	return weight;
}


int hashigherPrescedence(char a, char b)
{
	int aWeight = operatorWeight(a);
	int bWeight = operatorWeight(b);

	if (aWeight == bWeight)
	{
		if (IsRightAssociative(a)) return false;
		else return true;
	}

	return aWeight > bWeight ? true : false;
}

void enableDebug(bool bvalue)
{
	if (!bvalue) return;

	int tmpFlag = _CrtSetDbgFlag(_CRTDBG_REPORT_FLAG);

	// Turn on leak-checking bit.
	tmpFlag |= _CRTDBG_LEAK_CHECK_DF;

	// Turn off CRT block checking bit.
	tmpFlag &= ~_CRTDBG_CHECK_CRT_DF;

	// Set flag to the new value.
	_CrtSetDbgFlag(tmpFlag);
}

int main()
{

	string inFix("a/b*c");
	string postFix = "";
	LinkedBag<char> stack;
	int linenumber = inFix.length();

	for (int i = 0; i < linenumber; i++)
	{
		if (IsOperantor(inFix[i]))
		{
			while (!stack.isEmpty() && stack.getHead()->getItem() != '(' &&
				hashigherPrescedence(stack.getHead()->getItem(), inFix[i]))
			{
				postFix += stack.getHead()->getItem();
				stack.pop();

			}
			stack.push(inFix[i]);
		}
		else if (IsOperand(inFix[i]))
		{
			postFix += inFix[i];
		}

		else if (inFix[i] == '(')
		{
			stack.push(inFix[i]);
		}

		else if (inFix[i] == ')')
		{
			while (!stack.isEmpty() && stack.getHead()->getItem() != '(') {
				postFix += stack.getHead()->getItem();
				stack.pop();
			}
			stack.pop();
		}
	}

	while (!stack.isEmpty()) {
		postFix += stack.getHead()->getItem();
		stack.pop();
	}

	cout << postFix;

	getchar();


	enableDebug(true);

}  // end main
