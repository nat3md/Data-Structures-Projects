// Natnael Kebede
// Proffessor Larkin 


// No need for a linked list becuase collision is impossible due to this implimentation of a dynamic array

#include <cstdlib>
#include <iostream>
#include <string>
#include <memory>
#include<fstream>

using namespace std;

template<typename Key, typename Value>
struct Pair
{
	Key key;
	Value value;
	Pair (const Key& kee, const Value& val) { key = kee; value = val; }
};

template<typename Key, typename Value>
class ArrayBag
{
private:
	Pair<Key, Value> **table;
	int itemCount;
	int maxItems;
	int capacity;
public:



	ArrayBag() : itemCount(0), maxItems(0), capacity(500)
	{
		table = new Pair<Key, Value>*[capacity];
	}

	ArrayBag(const Key& kee, const Value& val)
	{
		Pair<Key, Value>(kee, val);
	}

	bool add(const Key& kee, const Value& val)
	{

		Pair<Key, Value>* nuEntry = new Pair<Key, Value>(kee, val);
		hashInsert(kee, nuEntry);
		return true;
	}

	int hashInsert(const Key& key, Pair<Key, Value>* item)
	{
		do
		{
			int i = 0;

			int hashIndex = hashFunction(key, i);

			if (hashIndex > capacity)
			{
				Pair<Key, Value> ** temp = new Pair<Key, Value>*[hashIndex];
				for (int k = 0; k < capacity; k++)
				{
					temp[k] = table[k];
				}
				delete[] table;
				table = temp;
			}

			if (table[hashIndex] == nullptr)
			{
				table[hashIndex] = item;
				itemCount++;
				return hashIndex + i;
			}

			i++;

		} while (true);

	}

	
	bool deleteKey(const Key& key)
	{
		int hashIndex = hashFunction(key);
		Pair<Key, Value>* getKey = table[hashIndex];
		int i = 1;
		do
		{
			if (getKey->key == key)
			{
				delete getKey;
			}
			else {
				getKey= table[hashIndex+i]
			}
		}while(true)
	
	}
	

	int hashFunction(const Key & product, int i)
	{

		int first = product[0];
		int third = product[2];
		int combo = first + third;
		combo = combo % capacity;
		combo += (product[1] + i);
		return combo;
	}


};



void enableDebug(bool bvalue)
{
	if (!bvalue) return;

	int tmpFlag = _CrtSetDbgFlag(_CRTDBG_REPORT_FLAG);

	// Turn on leak-checking bit.
	tmpFlag |= _CRTDBG_LEAK_CHECK_DF;

	// Turn off CRT block checking bit.
	tmpFlag &= ~_CRTDBG_CHECK_CRT_DF;

	// Set flag to the new value.
	_CrtSetDbgFlag(tmpFlag);
}

void main()
{


	ifstream inFile;
	string product = "";
	string price = "";
	ArrayBag<string, string> bag;

	inFile.open("UProducts.csv");

	if (inFile.is_open())
	{
		while (!inFile.eof())
		{
			getline(inFile, product, ',');
			getline(inFile, price);

			bag.add(product, price);

		}

	}
	else
	{
		cerr << "File Not found";
	}

	getchar();

}  // end main
