#include <array>
#include <iostream>
#include <string>
#include <memory>
#include <fstream>

using namespace std;

enum { INVALID = -1, DEFAULT_CAPACITY = 10 };	// Small size to test for a full bag



template<typename T>
class BagInterface
{
public:
	/** Gets the current number of entries in this bag.
	@return The integer number of entries currently in the bag. */
	virtual int getCurrentSize() const = 0;

	/** Sees whether this bag is empty.
	@return True if the bag is empty, or false if not. */
	virtual bool isEmpty() const = 0;

	/** Adds a new entry to this bag.
	@post  If successful, newEntry is stored in the bag and
	the count of items in the bag has increased by 1.
	@param newEntry  The object to be added as a new entry.
	@return  True if addition was successful, or false if not. */
	virtual bool add(const T& newEntry) = 0;

	/** Removes one occurrence of a given entry from this bag,
	if possible.
	@post  If successful, anEntry has been removed from the bag
	and the count of items in the bag has decreased by 1.
	@param anEntry  The entry to be removed.
	@return  True if removal was successful, or false if not. */
	virtual bool remove(const T& anEntry) = 0;

	/** Removes all entries from this bag.
	@post  Bag contains no items, and the count of items is 0. */
	virtual void clear() = 0;

	/** Counts the number of times a given entry appears in bag.
	@param anEntry  The entry to be counted.
	@return  The number of times anEntry appears in the bag. */
	virtual int getFrequencyOf(const T& anEntry) const = 0;

	/** Tests whether this bag contains a given entry.
	@param anEntry  The entry to locate.
	@return  True if bag contains anEntry, or false otherwise. */
	virtual bool contains(const T& anEntry) const = 0;

}; // end BagInterface




template<typename T>
class ArrayBag : public BagInterface<T>
{
private:
	unique_ptr<T[]> items;				   // Array of bag items
	int itemCount;                         // Current count of bag items 
	int maxItems;                          // Max capacity of the bag
public:
	ArrayBag() : itemCount(0), maxItems(DEFAULT_CAPACITY)
	{
		items = unique_ptr<T[]>(new T[DEFAULT_CAPACITY]);
	}  // end default constructor
	ArrayBag(int newCapacity) : itemCount(0), maxItems(newCapacity)
	{
		items = unique_ptr <T[]>(new T[newCapacity]);
	}
	int getMaxSize() const
	{
		return maxItems;
	}
	int getCurrentSize() const
	{
		return itemCount;
	}  // end getCurrentSize
	bool isEmpty() const
	{
		return itemCount == 0;
	}  // end isEmpty
	T& get(int index)
	{
		return items.get()[index];
	}
	bool add(const T& newEntry)
	{
		bool hasRoomToAdd = (itemCount < maxItems);
		if (hasRoomToAdd)
		{
			get(itemCount) = move(newEntry);
			itemCount++;
		}  // end if
		return hasRoomToAdd;
	}  // end add
	bool remove(const T& anEntry)
	{
		int locatedIndex = getIndexOf(anEntry, 0);
		bool canRemoveItem = !isEmpty() && (locatedIndex > INVALID);
		if (canRemoveItem)
		{
			itemCount--;
			get(locatedIndex) = move(get(itemCount));
		}  // end if

		return canRemoveItem;
	}  // end remove
	void clear()
	{
		itemCount = 0;
	}  // end clear
	bool contains(const T& anEntry) const
	{
		return getIndexOf(anEntry, 0) > INVALID;
	}  // end contains
	int getFrequencyOf(const T& anEntry) const
	{
		return countFrequency(anEntry, 0);
	}  // end getFrequencyOf
	int countFrequency(const T& anEntry, int searchIndex) const
	{
		int frequency = 0;
		if (searchIndex < itemCount)
		{
			if (items.get()[searchIndex] == anEntry)
			{
				frequency = 1 + countFrequency(anEntry, searchIndex + 1);
			}
			else
			{
				frequency = countFrequency(anEntry, searchIndex + 1);
			}  // end if
		}  // end if

		return frequency;
	}  // end countFrequency
	int getIndexOf(const T& target, int searchIndex) const
	{
		int result = -1;
		if (searchIndex < itemCount)
		{
			if (items.get()[searchIndex] == target)
			{
				result = searchIndex;
			}
			else
			{
				result = getIndexOf(target, searchIndex + 1);
			}  // end if
		}  // end if

		return result;
	}  // end getIndexOf
	T& getIndexValue(int index)
	{
		return items.get()[index];
	}
	void output()
	{
		for (int i = 0; i < itemCount; i++)
		{
			items[i].output();
		}
	}
	friend ostream& operator << (ostream& stream, ArrayBag<T>& bag)
	{
		stream << "The bag contains " << static_cast<int>(bag.getCurrentSize()) << " items:" << endl;
		for (int i = 0; i < bag.getCurrentSize(); i++)
		{
			stream << bag.getIndexValue(i).output();
		}  // end for
		stream << endl << endl;
		return stream;
	}  // end displayBag
};


template<typename T>
class Airport
{
private:
	string airportName;
	string city;
	string state;
	string latitude;
	string longitude;
public:
	Airport()
	{
		airportName = "";
		city = "";
		state = "";
		latitude = "0.0";
		longitude = "0.0";
	}
	Airport(string aName, string aCity, string aState, string aLatitude, string aLongitude)
	{
		airportName = aName;
		city = aCity;
		state = aState;
		latitude = aLatitude;
		longitude = aLongitude;
	}

	void readFile()
	{
		ArrayBag<Airport> *bag = new ArrayBag<Airport>(DEFAULT_CAPACITY);
		ifstream inFile;
		int capacityMultiplier = 2;
		string test = "";
		inFile.open("Airports.csv");


		while (inFile.peek() != EOF)
		{
			string airportName;
			string city;
			string state;
			string lat;
			string longitude;
			bool roomToAdd = false;

			getline(inFile, airportName, ',');
			getline(inFile, city, ',');
			getline(inFile, state, ',');
			getline(inFile, lat, ',');
			getline(inFile, longitude, '\n');

			Airport <string> temp(airportName, city, state, lat, longitude);

			roomToAdd = bag->add(temp);

			if (!roomToAdd)
			{
				ArrayBag<Airport> *tempBag = new ArrayBag<Airport>(DEFAULT_CAPACITY * capacityMultiplier);

				for (int i = 0; i < bag->getCurrentSize(); i++)
				{
					tempBag->add(bag->getIndexValue(i));
				}
				capacityMultiplier *= 2;
				bag = tempBag;
			}
		}
		inFile.close();
		
	}

	bool operator == (const Airport &B)
	{
		return (airportName == B.airportName);
	}
};


template<typename T>
class Node
{

private:
	
	unique_ptr<T>* next;
	unique_ptr<T>* prev;

public:
	Node() 
	{
		
		next = nullptr;
		prev = nullptr;
	}

	Node(const T& anitem)
	{
		item(anItem);
		next = nullptr;

	}

	Node(const ItemType& anItem, Node<T> *nextNodePtr)
	{

	}


};



void enableDebug(bool bvalue)
{
	if (!bvalue) return;

	int tmpFlag = _CrtSetDbgFlag(_CRTDBG_REPORT_FLAG);

	// Turn on leak-checking bit.
	tmpFlag |= _CRTDBG_LEAK_CHECK_DF;

	// Turn off CRT block checking bit.
	tmpFlag &= ~_CRTDBG_CHECK_CRT_DF;

	// Set flag to the new value.
	_CrtSetDbgFlag(tmpFlag);
}

int main()
{
	Airport<string> a;
	a.readFile();
	
	enableDebug(true);
} 
